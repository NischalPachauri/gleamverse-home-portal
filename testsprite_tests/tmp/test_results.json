[
  {
    "projectId": "0020c8b7-df75-4e64-935e-287696b75506",
    "testId": "1760945d-290c-4c3b-a32c-74ea9390676a",
    "userId": "84782448-8001-70a7-c042-59063c2dd7c7",
    "title": "TC001-search books by query and category",
    "description": "Verify that the /search endpoint returns a list of books matching the query parameter and optional category filter, ensuring accurate search results by title, author, or description.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:8080\"\nTIMEOUT = 30\n\ndef test_search_books_by_query_and_category():\n    # Define test queries and categories\n    test_cases = [\n        {\"query\": \"history\", \"category\": None},\n        {\"query\": \"history\", \"category\": \"Historical Fiction\"},\n        {\"query\": \"tolkien\", \"category\": None},\n        {\"query\": \"science fiction\", \"category\": \"Sci-Fi\"},\n        {\"query\": \"mystery\", \"category\": \"Thriller\"},\n    ]\n\n    for case in test_cases:\n        params = {\"query\": case[\"query\"]}\n        if case[\"category\"]:\n            params[\"category\"] = case[\"category\"]\n\n        try:\n            response = requests.get(f\"{BASE_URL}/search\", params=params, timeout=TIMEOUT)\n            response.raise_for_status()\n        except requests.RequestException as e:\n            assert False, f\"Request failed for params {params}: {e}\"\n\n        assert response.status_code == 200, f\"Expected 200 OK but got {response.status_code} for params {params}\"\n        try:\n            books = response.json()\n        except ValueError:\n            assert False, f\"Response is not valid JSON for params {params}: {response.text}\"\n\n        assert isinstance(books, list), f\"Response JSON is not a list for params {params}\"\n\n        # Verify each book matches query or category filter in title, author or description\n        for book in books:\n            # Check keys exist in book\n            for key in (\"title\", \"author\", \"description\", \"category\"):\n                assert key in book, f\"Book missing expected field '{key}': {book}\"\n\n            title = book[\"title\"].lower() if book[\"title\"] else \"\"\n            author = book[\"author\"].lower() if book[\"author\"] else \"\"\n            description = book[\"description\"].lower() if book[\"description\"] else \"\"\n            category = book[\"category\"].lower() if book[\"category\"] else \"\"\n\n            query_lower = case[\"query\"].lower()\n            category_lower = case[\"category\"].lower() if case[\"category\"] else None\n\n            # At least one of these fields (title, author, description) should contain the query\n            query_match = (query_lower in title) or (query_lower in author) or (query_lower in description)\n            assert query_match, f\"Book does not match query '{case['query']}': {book}\"\n\n            # If category filter provided, book category must match (case insensitive)\n            if category_lower:\n                assert category == category_lower, f\"Book category '{category}' does not match filter '{category_lower}': {book}\"\n\ntest_search_books_by_query_and_category()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/requests/models.py\", line 974, in json\n    return complexjson.loads(self.text, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/lang/lib/python3.12/site-packages/simplejson/__init__.py\", line 514, in loads\n    return _default_decoder.decode(s)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/lang/lib/python3.12/site-packages/simplejson/decoder.py\", line 386, in decode\n    obj, end = self.raw_decode(s)\n               ^^^^^^^^^^^^^^^^^^\n  File \"/var/lang/lib/python3.12/site-packages/simplejson/decoder.py\", line 416, in raw_decode\n    return self.scan_once(s, idx=_w(s, idx).end())\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nsimplejson.errors.JSONDecodeError: Expecting value: line 1 column 1 (char 0)\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"<string>\", line 29, in test_search_books_by_query_and_category\n  File \"/var/task/requests/models.py\", line 978, in json\n    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)\nrequests.exceptions.JSONDecodeError: Expecting value: line 1 column 1 (char 0)\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 57, in <module>\n  File \"<string>\", line 31, in test_search_books_by_query_and_category\nAssertionError: Response is not valid JSON for params {'query': 'history'}: <!doctype html>\r\n<html lang=\"en\">\r\n  <head>\n    <script type=\"module\">import { injectIntoGlobalHook } from \"/@react-refresh\";\ninjectIntoGlobalHook(window);\nwindow.$RefreshReg$ = () => {};\nwindow.$RefreshSig$ = () => (type) => type;</script>\n\n    <script type=\"module\" src=\"/@vite/client\"></script>\n\r\n    <meta charset=\"UTF-8\" />\r\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\r\n    <title>Free Public Library - Read & Download Books Online</title>\r\n    <meta name=\"description\" content=\"Access our free public library collection. Read books online with our integrated PDF reader or download them. Browse fantasy, fiction, and more.\" />\r\n    <meta name=\"author\" content=\"Free Public Library\" />\r\n\r\n    <meta property=\"og:title\" content=\"Free Public Library - Read & Download Books Online\" />\r\n    <meta property=\"og:description\" content=\"Access our free public library collection. Read books online with our integrated PDF reader or download them.\" />\r\n    <meta property=\"og:type\" content=\"website\" />\r\n    <meta property=\"og:image\" content=\"https://lovable.dev/opengraph-image-p98pqg.png\" />\r\n\r\n    <meta name=\"twitter:card\" content=\"summary_large_image\" />\r\n    <meta name=\"twitter:site\" content=\"@lovable_dev\" />\r\n    <meta name=\"twitter:image\" content=\"https://lovable.dev/opengraph-image-p98pqg.png\" />\r\n  </head>\r\n\r\n  <body>\r\n    <div id=\"root\"></div>\r\n    <script type=\"module\" src=\"/src/main.tsx?t=1761041561909\"></script>\r\n  </body>\r\n</html>\r\n\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-10-21T10:14:30.281Z",
    "modified": "2025-10-21T10:14:56.135Z"
  },
  {
    "projectId": "0020c8b7-df75-4e64-935e-287696b75506",
    "testId": "469911d3-f644-49c9-8732-e26cb5e49f7e",
    "userId": "84782448-8001-70a7-c042-59063c2dd7c7",
    "title": "TC002-open pdf reader for a specific book",
    "description": "Test the /reader/{bookId} endpoint to ensure it opens the PDF reader interface for the given bookId, supporting page navigation, zoom controls, and two-page mode.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:8080\"\nTIMEOUT = 30\n\ndef test_open_pdf_reader_for_specific_book():\n    try:\n        # Search for books with a generic query to get at least one bookId\n        search_resp = requests.get(\n            f\"{BASE_URL}/search\",\n            params={\"query\": \"a\"},  # broad query to get some results\n            timeout=TIMEOUT\n        )\n        assert search_resp.status_code == 200, f\"Failed to search books: {search_resp.status_code}\"\n        books = search_resp.json()\n        assert isinstance(books, list) and len(books) > 0, \"No books found in search response\"\n        book_id = books[0].get(\"id\")\n        assert book_id, \"Book object missing 'id' field\"\n\n        # Open the PDF reader for the obtained bookId\n        reader_resp = requests.get(f\"{BASE_URL}/reader/{book_id}\", timeout=TIMEOUT)\n        assert reader_resp.status_code == 200, f\"Failed to open PDF reader for bookId {book_id}\"\n        content_type = reader_resp.headers.get(\"Content-Type\", \"\")\n        assert \"html\" in content_type.lower(), \"Unexpected Content-Type for PDF reader interface\"\n\n        html_content = reader_resp.text.lower()\n        assert any(term in html_content for term in [\"page\", \"zoom\", \"two-page\", \"reader\"]), \\\n            \"PDF reader interface HTML missing expected navigation or zoom terms\"\n\n    except requests.RequestException as e:\n        assert False, f\"Request failed: {e}\"\n\n    except AssertionError as e:\n        assert False, str(e)\n\ntest_open_pdf_reader_for_specific_book()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/requests/models.py\", line 974, in json\n    return complexjson.loads(self.text, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/lang/lib/python3.12/site-packages/simplejson/__init__.py\", line 514, in loads\n    return _default_decoder.decode(s)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/lang/lib/python3.12/site-packages/simplejson/decoder.py\", line 386, in decode\n    obj, end = self.raw_decode(s)\n               ^^^^^^^^^^^^^^^^^^\n  File \"/var/lang/lib/python3.12/site-packages/simplejson/decoder.py\", line 416, in raw_decode\n    return self.scan_once(s, idx=_w(s, idx).end())\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nsimplejson.errors.JSONDecodeError: Expecting value: line 1 column 1 (char 0)\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"<string>\", line 15, in test_open_pdf_reader_for_specific_book\n  File \"/var/task/requests/models.py\", line 978, in json\n    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)\nrequests.exceptions.JSONDecodeError: Expecting value: line 1 column 1 (char 0)\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 36, in <module>\n  File \"<string>\", line 31, in test_open_pdf_reader_for_specific_book\nAssertionError: Request failed: Expecting value: line 1 column 1 (char 0)\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-10-21T10:14:30.287Z",
    "modified": "2025-10-21T10:15:13.844Z"
  },
  {
    "projectId": "0020c8b7-df75-4e64-935e-287696b75506",
    "testId": "d4db315d-7fb7-4314-b2ed-ccc709bef3db",
    "userId": "84782448-8001-70a7-c042-59063c2dd7c7",
    "title": "TC003-user login with valid credentials",
    "description": "Validate the /login endpoint by submitting valid email and password, expecting a successful login response and proper authentication handling.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:8080\"\nLOGIN_ENDPOINT = f\"{BASE_URL}/login\"\n\ndef test_user_login_with_valid_credentials():\n    # Use valid credentials (these should be valid in the test environment)\n    login_payload = {\n        \"email\": \"testuser@example.com\",\n        \"password\": \"SecurePass123\"\n    }\n    headers = {\n        \"Content-Type\": \"application/json\"\n    }\n    try:\n        response = requests.post(\n            LOGIN_ENDPOINT,\n            json=login_payload,\n            headers=headers,\n            timeout=30\n        )\n        # Assert status code 200 for successful login\n        assert response.status_code == 200, f\"Expected status code 200, got {response.status_code}\"\n        # Check if response contains expected fields indicating successful authentication, e.g., token or user info\n        json_response = response.json()\n        assert isinstance(json_response, dict), \"Response is not a JSON object\"\n        # Common keys returned on login success might be \"token\", \"user\", or similar. Check for at least one.\n        assert (\"token\" in json_response) or (\"user\" in json_response), \"Response missing authentication tokens or user info\"\n        # Optionally validate token is a non-empty string if present\n        if \"token\" in json_response:\n            token = json_response[\"token\"]\n            assert isinstance(token, str) and len(token) > 0, \"Token is invalid\"\n        # If user info returned, verify expected fields\n        if \"user\" in json_response:\n            user = json_response[\"user\"]\n            assert isinstance(user, dict), \"User field is not an object\"\n            assert \"email\" in user, \"User info missing email\"\n            assert user[\"email\"].lower() == login_payload[\"email\"].lower(), \"Returned user email does not match login email\"\n    except requests.exceptions.RequestException as e:\n        assert False, f\"Request to /login failed: {e}\"\n\ntest_user_login_with_valid_credentials()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 42, in <module>\n  File \"<string>\", line 23, in test_user_login_with_valid_credentials\nAssertionError: Expected status code 200, got 404\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-10-21T10:14:30.292Z",
    "modified": "2025-10-21T10:14:55.821Z"
  },
  {
    "projectId": "0020c8b7-df75-4e64-935e-287696b75506",
    "testId": "466ce358-5c6a-44ea-a728-002de7fcf069",
    "userId": "84782448-8001-70a7-c042-59063c2dd7c7",
    "title": "TC004-user registration with required details",
    "description": "Test the /register endpoint by providing valid email, password, and name, verifying successful user registration and profile creation.",
    "code": "import requests\nimport uuid\n\nBASE_URL = \"http://localhost:8080\"\nREGISTER_ENDPOINT = f\"{BASE_URL}/register\"\nTIMEOUT = 30\n\ndef test_user_registration_with_required_details():\n    # Generate unique email to avoid duplication conflicts in repeated tests\n    unique_email = f\"testuser_{uuid.uuid4().hex[:8]}@example.com\"\n    password = \"TestPassword123!\"\n    name = \"Test User\"\n\n    payload = {\n        \"email\": unique_email,\n        \"password\": password,\n        \"name\": name\n    }\n    headers = {\n        \"Content-Type\": \"application/json\"\n    }\n\n    # Register user\n    response = requests.post(REGISTER_ENDPOINT, json=payload, headers=headers, timeout=TIMEOUT)\n    try:\n        # Assert status code 200 for successful registration\n        assert response.status_code == 200, f\"Expected status code 200, got {response.status_code}\"\n        # Attempt to parse JSON response\n        response_json = response.json()\n        # Verify response has expected fields (at minimum an id or user data)\n        assert isinstance(response_json, dict), \"Response is not a JSON object\"\n\n        # Check that user id or confirmation is present to confirm creation\n        # Possible keys: \"id\", \"userId\", \"message\", or similar\n        keys = response_json.keys()\n        has_id = any(k.lower() in [\"id\", \"userid\", \"user_id\", \"userId\"] for k in keys)\n        has_message = any(\"success\" in str(v).lower() for v in response_json.values())\n        assert has_id or has_message, \"Response does not confirm successful registration\"\n\n    except ValueError:\n        assert False, \"Response is not valid JSON\"\n\ntest_user_registration_with_required_details()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 43, in <module>\n  File \"<string>\", line 27, in test_user_registration_with_required_details\nAssertionError: Expected status code 200, got 404\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-10-21T10:14:30.296Z",
    "modified": "2025-10-21T10:14:55.832Z"
  },
  {
    "projectId": "0020c8b7-df75-4e64-935e-287696b75506",
    "testId": "cbe5b0fe-2fa7-4184-9cfc-b9e4a90a03d4",
    "userId": "84782448-8001-70a7-c042-59063c2dd7c7",
    "title": "TC005-update book reading status",
    "description": "Verify the /book/{bookId}/status endpoint allows updating the reading status of a book to one of the allowed values (Planning to read, Reading, On hold, Completed) and returns a success response.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:8080\"\nTIMEOUT = 30\n\n# Assuming authentication is required, login to get a token (adjust credentials as needed)\ndef authenticate():\n    login_url = f\"{BASE_URL}/login\"\n    credentials = {\n        \"email\": \"testuser@example.com\",\n        \"password\": \"TestPassword123!\"\n    }\n    resp = requests.post(login_url, json=credentials, timeout=TIMEOUT)\n    resp.raise_for_status()\n    json_resp = resp.json()\n    token = json_resp.get(\"token\") or json_resp.get(\"access_token\")\n    assert token, \"Authentication token not found in login response\"\n    return token\n\n# use a dummy book id for testing status update since create book API is not in PRD\n\ndef test_update_book_reading_status():\n    token = authenticate()\n    headers = {\n        \"Authorization\": f\"Bearer {token}\",\n        \"Content-Type\": \"application/json\"\n    }\n\n    # Dummy book ID to test status update - replace with real book ID in actual tests\n    book_id = \"dummy-book-id\"\n    url = f\"{BASE_URL}/book/{book_id}/status\"\n    allowed_statuses = [\"Planning to read\", \"Reading\", \"On hold\", \"Completed\"]\n\n    for status in allowed_statuses:\n        payload = {\"status\": status}\n        response = requests.put(url, json=payload, headers=headers, timeout=TIMEOUT)\n        assert response.status_code == 200, f\"Failed to update status to '{status}': {response.text}\"\n\n    # Test invalid status returns error\n    invalid_payload = {\"status\": \"InvalidStatus\"}\n    invalid_response = requests.put(url, json=invalid_payload, headers=headers, timeout=TIMEOUT)\n    assert invalid_response.status_code != 200, \"API accepted invalid status value\"\n\n\ntest_update_book_reading_status()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 45, in <module>\n  File \"<string>\", line 23, in test_update_book_reading_status\n  File \"<string>\", line 14, in authenticate\n  File \"/var/task/requests/models.py\", line 1024, in raise_for_status\n    raise HTTPError(http_error_msg, response=self)\nrequests.exceptions.HTTPError: 404 Client Error: Not Found for url: http://localhost:8080/login\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-10-21T10:14:30.301Z",
    "modified": "2025-10-21T10:15:12.278Z"
  },
  {
    "projectId": "0020c8b7-df75-4e64-935e-287696b75506",
    "testId": "fed86231-332e-4a5e-a8ff-2539f4f46c81",
    "userId": "84782448-8001-70a7-c042-59063c2dd7c7",
    "title": "TC006-retrieve top books for carousel display",
    "description": "Test the /top-books endpoint to ensure it returns a list of top trending books for the carousel, supporting infinite looping and correct author information.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:8080\"\nTIMEOUT = 30\n\ndef test_retrieve_top_books_for_carousel_display():\n    url = f\"{BASE_URL}/top-books\"\n    headers = {\n        \"Accept\": \"application/json\"\n    }\n    try:\n        response = requests.get(url, headers=headers, timeout=TIMEOUT)\n        # Assert status code 200 OK\n        assert response.status_code == 200, f\"Expected status code 200, got {response.status_code}\"\n        data = response.json()\n        # Assert response is a list\n        assert isinstance(data, list), \"Response is not a list\"\n        # Assert list is not empty (assuming there should be some top books)\n        assert len(data) > 0, \"Top books list is empty\"\n        # Check each book for required fields including author information\n        for book in data:\n            assert isinstance(book, dict), \"Book item is not a dictionary\"\n            # Required keys in each book (at minimum)\n            expected_keys = {\"id\", \"title\", \"author\"}\n            missing_keys = expected_keys - book.keys()\n            assert not missing_keys, f\"Missing keys in book item: {missing_keys}\"\n            # Author info should be a non-empty string or object with name\n            author = book[\"author\"]\n            # Author can be a string (name) or a dict containing author info\n            assert author is not None, \"Author info is None\"\n            if isinstance(author, dict):\n                assert \"name\" in author and author[\"name\"], \"Author dict missing 'name' or it is empty\"\n            elif isinstance(author, str):\n                assert author.strip(), \"Author string is empty\"\n            else:\n                assert False, f\"Author field has unexpected type: {type(author)}\"\n        # Additional: check if carousel supports infinite looping - can only infer from data length > 1 for looping\n        assert len(data) > 1, \"Top books list too short for infinite looping carousel\"\n    except requests.RequestException as e:\n        assert False, f\"Request to /top-books failed: {str(e)}\"\n\ntest_retrieve_top_books_for_carousel_display()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 42, in <module>\n  File \"<string>\", line 14, in test_retrieve_top_books_for_carousel_display\nAssertionError: Expected status code 200, got 404\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-10-21T10:14:30.307Z",
    "modified": "2025-10-21T10:14:54.555Z"
  },
  {
    "projectId": "0020c8b7-df75-4e64-935e-287696b75506",
    "testId": "4666afa0-a0a3-4e85-92b7-540d80a8d226",
    "userId": "84782448-8001-70a7-c042-59063c2dd7c7",
    "title": "TC007-toggle and persist user theme preference",
    "description": "Validate the /theme endpoint to toggle between dark and light themes, ensuring the preference is saved and persists across user sessions.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:8080\"\nTIMEOUT = 30\n\ndef test_toggle_and_persist_user_theme_preference():\n    session = requests.Session()\n\n    # Step 1: Get current theme preference (assumed via GET /theme; not in PRD, so we check /theme toggle effect)\n    # Since no GET /theme is defined, we'll toggle twice and check if the theme preference toggles back accordingly\n\n    try:\n        # Toggle theme first time\n        response1 = session.post(f\"{BASE_URL}/theme\", timeout=TIMEOUT)\n        assert response1.status_code == 200, f\"Expected 200 OK, got {response1.status_code}\"\n        json1 = response1.json() if response1.content else {}\n        # We expect the theme toggled successfully message or indicator in response\n        assert (\"theme\" in json1 and json1[\"theme\"] in [\"light\", \"dark\"]) or not json1, \"Response should indicate current theme or be empty\"\n\n        theme_after_first_toggle = json1.get(\"theme\", None)\n\n        # Simulate new session by creating a new session object (cookies, headers, auth persisting)\n        session2 = requests.Session()\n\n        # Without toggling, check if theme preference persists on a new toggle:\n        # We toggle theme again and expect to toggle back to original theme\n        response2 = session2.post(f\"{BASE_URL}/theme\", timeout=TIMEOUT)\n        assert response2.status_code == 200, f\"Expected 200 OK on second toggle, got {response2.status_code}\"\n        json2 = response2.json() if response2.content else {}\n        assert (\"theme\" in json2 and json2[\"theme\"] in [\"light\", \"dark\"]) or not json2, \"Response should indicate toggled theme or be empty\"\n\n        theme_after_second_toggle = json2.get(\"theme\", None)\n\n        # If first toggle changed theme to dark, second toggle should revert it to light and vice versa\n        if theme_after_first_toggle and theme_after_second_toggle:\n            assert theme_after_first_toggle != theme_after_second_toggle, \"Theme should toggle between light and dark\"\n\n        # Third toggle with same session to confirm persistence back to first state\n        response3 = session2.post(f\"{BASE_URL}/theme\", timeout=TIMEOUT)\n        assert response3.status_code == 200, f\"Expected 200 OK on third toggle, got {response3.status_code}\"\n        json3 = response3.json() if response3.content else {}\n        theme_after_third_toggle = json3.get(\"theme\", None)\n        if theme_after_second_toggle and theme_after_third_toggle:\n            assert theme_after_second_toggle != theme_after_third_toggle, \"Theme should toggle again between light and dark\"\n\n    except requests.RequestException as e:\n        assert False, f\"Request failed: {e}\"\n\ntest_toggle_and_persist_user_theme_preference()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 49, in <module>\n  File \"<string>\", line 15, in test_toggle_and_persist_user_theme_preference\nAssertionError: Expected 200 OK, got 404\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-10-21T10:14:30.312Z",
    "modified": "2025-10-21T10:14:58.782Z"
  }
]
