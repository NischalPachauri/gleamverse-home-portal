var FLIPBOOK = FLIPBOOK || {};

FLIPBOOK.PdfService = function (pdfDocument, model, options) {
  this.pdfDocument = pdfDocument;
  this.model = model;
  this.options = options;
  this.viewports = [];
  this.numPages = 0;
  this.double = false;
};

FLIPBOOK.PdfService.prototype = {
  init: function () {
    var self = this;
    FLIPBOOK.currentPdfService = self; // Expose globally for Book3 to find
    console.log("PdfService: Initializing with document", this.pdfDocument);
    // Get first page to determine size/viewports
    this.pdfDocument.getPage(1).then(function (page) {
      console.log("PdfService: Got first page", page);
      var viewport = page.getViewport({ scale: 1 });
      self.viewports = [viewport, viewport]; // Assume similar pages
      self.numPages = self.pdfDocument.numPages;
      console.log("PdfService: Num pages:", self.numPages);

      // Trigger 'pdfinit' event on model to notify flipbook that service is ready
      if (self.model) {
        console.log("PdfService: Triggering pdfinit with", self.numPages, "pages");
        // Try both ways to be safe (jQuery style array vs direct arg)
        self.model.trigger('pdfinit', [self.numPages]);

        // Also trigger on window/document in case Main listens there
        var event = new CustomEvent('pdfinit', { detail: { numPages: self.numPages } });
        if (typeof window !== 'undefined') window.dispatchEvent(event);
        if (typeof document !== 'undefined') document.dispatchEvent(event);
      }
    }).catch(function (err) {
      console.error("PdfService: Error initializing:", err);
    });
  },

  renderBookPage: function (pageIndex, size, callback) {
    console.log("PdfService: renderBookPage requested for index", pageIndex);
    var self = this;
    // pageIndex is 0-based, pdfjs is 1-based
    if (pageIndex < 0 || pageIndex >= this.numPages) {
      console.warn("PdfService: Invalid page index", pageIndex);
      if (callback) callback.call(self, {});
      return;
    }

    this.pdfDocument.getPage(pageIndex + 1).then(function (page) {
      var viewport = page.getViewport({ scale: 1 });
      // Calculate scale to fit 'size' (height)
      var scale = size / viewport.height;
      var scaledViewport = page.getViewport({ scale: scale });

      var canvas = document.createElement('canvas');
      var context = canvas.getContext('2d');
      canvas.height = scaledViewport.height;
      canvas.width = scaledViewport.width;

      var renderContext = {
        canvasContext: context,
        viewport: scaledViewport
      };

      page.render(renderContext).promise.then(function () {
        console.log("PdfService: Page rendered successfully", pageIndex);
        if (callback) {
          callback.call(self, {
            canvas: canvas,
            index: pageIndex,
            size: size,
            image: canvas // Some parts might expect image
          });
        }
      });
    }).catch(function (err) {
      console.error("PdfService: Error rendering page " + pageIndex, err);
      if (callback) callback.call(self, {});
    });
  },

  loadOutline: function (callback) {
    this.pdfDocument.getOutline().then(function (outline) {
      if (callback) callback(outline);
    }).catch(function () {
      if (callback) callback(null);
    });
  },

  loadTextLayer: function (pageIndex, callback) {
    // Minimal implementation: just return empty for now to avoid errors
    // If text selection is needed, this would need to extract text content
    if (callback) callback.call(this, "", pageIndex);
  },

  setRightIndex: function (index) {
    // Used for updating state, no-op for basic rendering
  }
};